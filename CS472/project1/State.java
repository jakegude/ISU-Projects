package edu.iastate.cs472.proj1;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 *  
 * @author jakegude
 *
 */

/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board = new int[3][3]; 		// configuration of tiles 
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state
	public static Heuristic heu; // heuristic used. shared by all the states. 
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this stateand the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double move counted as one; negative if not computed yet. 
	public int emptyRow = -1;
	public int emptyCol = -1;
	
	/**
	 * blank board for head 
	 */
	public State() {
		move = null;
    	numMoves = 0;
    	next = null;
    	previous = null;
    	predecessor = null;
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board[i].length; j++) {
        		board[ i ][ j ] = -1;
    		}
    	}
	}
	
	/**
	 * copy board for copy constructor
	 */
	public State(State s) {
		move = s.move;
    	numMoves = s.numMoves;
    	next = s.next;
    	previous = s.previous;
    	predecessor = s.predecessor;
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board[i].length; j++) {
    			if (board[ i ][ j ] <= 8 && board[ i ][ j ] >= 0) {
        			this.board[ i ][ j ] = s.board[ i ][ j ];
    			} else {
    				throw new IllegalArgumentException();
    			}
    		}
    	}
	}
	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException 
    {
    	if (board.length > 3 || board[0].length > 3 || board.length <= 0 || board[0].length <= 0) {
    		throw new IllegalArgumentException();
    	}
    	
    	move = null;
    	numMoves = 0;
    	next = null;
    	previous = null;
    	predecessor = null;
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board[i].length; j++) {
    			if (board[ i ][ j ] <= 8 && board[ i ][ j ] >= 0) {
        			this.board[ i ][ j ] = board[ i ][ j ];
    			} else {
    				throw new IllegalArgumentException();
    			}
    		}
    	}
	}
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
    	try {
    		File f = new File(inputFileName);
        	Scanner s = new Scanner(f);
        	int rownum = 0;
        	move = null;
        	numMoves = 0;
        	while (s.hasNextLine() && rownum < 3) {
        		int colone = s.nextInt();
        		int coltwo = s.nextInt();
        		int colthree = s.nextInt();
        		if (colone <= 8 && colone >= 0) {
            		board[rownum][0] = colone;
        		} else {
        			throw new IllegalArgumentException();
        		}
        		if (coltwo <= 8 && coltwo >= 0) {
            		board[rownum][1] = coltwo;
        		} else {
        			throw new IllegalArgumentException();
        		}
        		
        		if (colthree <= 8 && colthree >= 0) {
            		board[rownum][2] = colthree;
        		} else {
        			throw new IllegalArgumentException();
        		}
        		rownum++;
        	}
    	} catch (FileNotFoundException e) {
    		e.printStackTrace();
    	} catch (IllegalArgumentException e) {
    		e.printStackTrace();
    	}
	}
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
    	FindEmptySpace();
    	if (m == Move.LEFT 					&& emptyCol == 2 ||
    			m == Move.RIGHT				&& emptyCol == 0 ||
    			m == Move.UP 					&& emptyRow == 2 ||
    			m == Move.DOWN 				&& emptyRow == 0 ||
    			m == Move.DBL_LEFT 		&& emptyCol != 0 ||
    			m == Move.DBL_RIGHT 	&& emptyCol != 2 ||
    			m == Move.DBL_UP 			&& emptyRow != 0 ||
    			m == Move.DBL_DOWN 	&& emptyRow != 2 ) 
    	{
    		throw new IllegalArgumentException();
    	} 
    	
    	State successor = new State(this);
    	int temp1 = -1;
    	int temp2 = -1;
    	successor.predecessor = (State) this;
    	successor.move = m;
    	successor.next = null;
    	successor.previous = null;
    	successor.numMoves = numMoves + 1;
    	if (m == Move.DBL_UP) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow+1][emptyCol]); //UP
    		temp1 = successor.board[emptyRow+1][emptyCol];
    		temp2 = successor.board[emptyRow+2][emptyCol];
    		successor.board[emptyRow][emptyCol] = temp1;
    		successor.board[emptyRow+1][emptyCol] = temp2;    		
    		successor.board[emptyRow+2][emptyCol] = 0;
    	} 
    	if (m == Move.DBL_DOWN) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow-1][emptyCol]); //DOWN
    		temp1 = successor.board[emptyRow-1][emptyCol];
    		temp2 = successor.board[emptyRow-2][emptyCol];
    		successor.board[emptyRow][emptyCol] = temp1;
    		successor.board[emptyRow-1][emptyCol] = temp2;    		
    		successor.board[emptyRow-2][emptyCol] = 0;
    	} 
    	if (m == Move.DBL_LEFT) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow][emptyCol+1]); //LEFT
    		temp1 = successor.board[emptyRow][emptyCol+1];
    		temp2 = successor.board[emptyRow][emptyCol+2];
    		successor.board[emptyRow][emptyCol] = temp1;
    		successor.board[emptyRow][emptyCol+1] = temp2;    		
    		successor.board[emptyRow][emptyCol+2] = 0;
    	} 
    	if (m == Move.DBL_RIGHT) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow][emptyCol-1]); //RIGHT
    		temp1 = successor.board[emptyRow][emptyCol-1];
    		temp2 = successor.board[emptyRow][emptyCol-2];
    		successor.board[emptyRow][emptyCol] = temp1;
    		successor.board[emptyRow][emptyCol-1] = temp2;    		
    		successor.board[emptyRow][emptyCol-2] = 0;
    	} 
    	if (m == Move.UP) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow+1][emptyCol]); //UP
    		temp1 = successor.board[emptyRow+1][emptyCol];
    		successor.board[emptyRow+1][emptyCol] = 0;
    		successor.board[emptyRow][emptyCol] = temp1;
    	} 
    	if (m == Move.DOWN) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow-1][emptyCol]); //DOWN
    		temp1 = successor.board[emptyRow-1][emptyCol];
    		successor.board[emptyRow-1][emptyCol] = 0;
    		successor.board[emptyRow][emptyCol] = temp1;
    	}
    	if (m == Move.LEFT) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow][emptyCol+1]); //LEFT
    		temp1 = successor.board[emptyRow][emptyCol+1];
    		successor.board[emptyRow][emptyCol+1] = 0;
    		successor.board[emptyRow][emptyCol] = temp1;
    	}
    	if (m == Move.RIGHT) {
//    		swap(successor.board[emptyRow][emptyCol], successor.board[emptyRow+1][emptyCol-1]); //RIGHT
    		temp1 = successor.board[emptyRow][emptyCol-1];
    		successor.board[emptyRow][emptyCol-1] = 0;
    		successor.board[emptyRow][emptyCol] = temp1;
    	} 
    	return successor;
    }
    
    public void swap(int i, int j) {
    	int temp = i;
    	i = j;
    	j = temp;
    }
    
    public void FindEmptySpace() {
    	if (board[0][0] == -1) return;
    	for (int i = 0; i < 3; i++) {
    		for (int j = 0; j < 3; j++) {
    			if (board[ i ][ j ] == 0) {
    				emptyRow = i;
    				emptyCol = j;
    			}
    		}
    	}
    }
    
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
    	int inversionCount = 0;
    	int goalInversions = 7;
    	
    	int[] lineboard = new int [9];
    	int index = 0;
    	for (int i = 0; i < board.length; i++) {
    		for (int j = 0; j < board.length; j++) {
    			lineboard[index] = board[ i ][ j ];
    			index++;
    		}
    	}
    	for (int i = 0; i < index; i++ ) {
    		if (lineboard[i] == 0) {
    			continue;
    		}
    		for (int j = i + 1; j < index; j++) {
    			if (lineboard[i] > lineboard[j] && lineboard[j] != 0) {
    				inversionCount++;
    			}
    		}
    	}
//    	System.out.println(inversionCount);
    	return (Math.abs(goalInversions - inversionCount) % 2 == 0);
    }
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState()
    {
    	if (board[ 0 ][ 0 ] != 1  || board[ 0 ][ 1 ] != 2 || board[ 0 ][ 2 ] != 3 ||
    			board[ 1 ][ 0 ] != 8 || board[ 1 ][ 1 ] != 0 || board[ 1 ][ 2 ] != 4 ||
    			board[ 2 ][ 0 ] != 7 || board[ 2 ][ 1 ] != 6 || board[ 2 ][ 2 ] != 5 ) {
    		return false;
    	}
    	return true;
    }
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString()
    {
    	String output =  "";
    	
    	for (int i = 0; i < 3; i++) {
    		for (int j = 0; j < 3; j++) {
    			int numtoadd = board[ i ][ j ];
    			String s = Integer.toString(numtoadd);
    			if (j != 2) {
    				output += s + " ";
    			} else {
    				output += s + "\n";
    			} 
    		}
    	}
    	return output; 
    }
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
    	State newstate = new State(this.board);
    	newstate.next = null;
    	newstate.previous = null;
    	newstate.predecessor = null;
    	return (State) newstate;
    }

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
    	if (o == null) return false;
    	State s = (State) o;
    	for (int i = 0; i < 3; i++) {
    		for (int j = 0; j < 3; j++) {
    			if (this.board[ i ][ j ] != s.board[ i ][ j ]) {
    				return false;
    			}
    		}
    	}
    	return true;
    }
            
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeManhattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is neither 0 nor 1. 
     */
    public int cost() throws IllegalArgumentException
    {
    	
    	
    	if (heu == Heuristic.TileMismatch)  {
    		return numMoves + computeNumMismatchedTiles();
    		
    	}
    	if (heu == Heuristic.ManhattanDist) {
    		return numMoves + computeManhattanDistance();
    		
    	} 
    	if (heu == Heuristic.DoubleMoveHeuristic) {
    		return numMoves +  computeNumSingleDoubleMoves();
    		
    	}
    	return 0;
    }
 
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
    	int thiscost = this.cost();
    	int scost = s.cost();
    	if (thiscost < scost) return -1;
    	if (thiscost == scost) return 0;
    	return 1;		
    }
   
    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles()
	{
		if (numMismatchedTiles >= 0) return numMismatchedTiles;
		int ret = 0;
		if (board[ 0 ][ 0 ] != 1)	ret++;
		if (board[ 0 ][ 1 ] != 2) ret++;
		if (board[ 0 ][ 2 ] != 3) ret++;
    	if (board[ 1 ][ 0 ] != 8) ret++;
    	if (board[ 1 ][ 1 ] != 0) ret++;
    	if (board[ 1 ][ 2 ] != 4) ret++;
   		if (board[ 2 ][ 0 ] != 7) ret++;
   		if (board[ 2 ][ 1 ] != 6) ret++;
    	if (board[ 2 ][ 2 ] != 5 ) ret++;
    	return ret;
	}

	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance() {
		if (ManhattanDistance >= 0) return ManhattanDistance;
		int ret = 0;
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board.length; j++) {
				 if (board[i][j] == 1) {
					 ret += Manhattan(i, j, 0, 0);
				 }
				 if (board[i][j] == 2) {
					 ret += Manhattan(i, j, 0, 1);
				 }
				 if (board[i][j] == 3) {
					 ret += Manhattan(i, j, 0, 2);
				 }
				 if (board[i][j] == 4) {
					 ret += Manhattan(i, j, 1, 2);
				 }
				 if (board[i][j] == 5) {
					 ret += Manhattan(i, j, 2, 2);
				 }
				 if (board[i][j] == 6) {
					 ret += Manhattan(i, j, 2, 1);
				 }
				 if (board[i][j] == 7) {
					 ret += Manhattan(i, j, 2, 0);
				 }
				 if (board[i][j] == 8) {
					 ret += Manhattan(i, j, 1, 0);
				}
				if (board[i][j] == 0) {
					 ret += Manhattan(i, j, 1, 1);
				}
			}
		}
		
		 return ret;
	}
	
	private int Manhattan(int i, int j, int row, int col) {
		return Math.abs(row - i) + Math.abs(col - j);
	}
		
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value 
	 * otherwise. 
	 * 
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves, 
	 *         single or double, which will take this state to the goal state.
	 */
	private int computeNumSingleDoubleMoves()
	{
		if (numSingleDoubleMoves >= 0) return numSingleDoubleMoves;
		int ret = Math.min(computeManhattanDistance(), computeNumMismatchedTiles());
//		int ret = computeManhattanDistance() /2;

		return ret;
	}
}
